# üè¶ Banco √Ågil ‚Äî Sistema de Atendimento Inteligente com Arquitetura Multi-Agente

## üìå Sum√°rio Executivo

Este projeto implementa um sistema de atendimento banc√°rio utilizando uma **arquitetura de agentes especializados**, orquestrados por um **StateGraph do LangGraph**, garantindo controle determin√≠stico de fluxo, persist√™ncia contextual e execu√ß√£o orientada a regras de neg√≥cio.

O objetivo √© simular um ambiente de atendimento realista, por√©m com seguran√ßa, previsibilidade e auditabilidade ‚Äî caracter√≠sticas essenciais em cen√°rios financeiros.

---

## üß© Arquitetura Geral

A solu√ß√£o √© composta por quatro agentes independentes:

- **Triagem:** Autentica√ß√£o + inten√ß√£o.
- **Cr√©dito:** An√°lise de aumento de limite com regras determin√≠sticas.
- **Entrevista:** Coleta estruturada de dados para rec√°lculo de score.
- **C√¢mbio:** Consulta de cota√ß√µes via tool.

A intera√ß√£o entre os agentes √© controlada pelo **LangGraph (StateGraph)**, que permite:

- Roteamento baseado em estado.
- Ciclos (ex.: rejei√ß√£o ‚Üí entrevista ‚Üí cr√©dito).
- Persist√™ncia de estado por sess√£o/thread.
- Controle expl√≠cito de transi√ß√µes via ferramentas e l√≥gica Python.

---

## üîß Tecnologias Utilizadas

| Componente | Tecnologia | Justificativa |
| :--- | :--- | :--- |
| **Orquestra√ß√£o** | **LangGraph** | Permite modelos com loops, roteamento condicional e estado persistente. |
| **LLM** | **Google Gemini 1.5 Flash** | Baixo custo, r√°pidas tool-calls, ideal para classifica√ß√£o e roteamento. |
| **Interface** | **Streamlit** | Facilita implementa√ß√£o de chat interativo para valida√ß√£o visual. |
| **Tools** | **Fun√ß√µes Python** | Evita alucina√ß√µes e garante deterministicidade em c√°lculos financeiros. |

---

## üèõÔ∏è Modelo de Estado (AgentState)

O sistema utiliza um dicion√°rio tipado respons√°vel por consolidar:

- Hist√≥rico de mensagens.
- Dados do cliente (CPF, nome, score, limite).
- Flags essenciais (`authenticated`, `interview_complete`, `next_agent`, `last_intent`).

O uso de `Annotated` permite opera√ß√µes de merge customizadas para hist√≥rico e vari√°veis persistentes.

---

## üîÄ Fluxo entre Agentes (StateGraph)

A arquitetura segue o seguinte fluxo:

```mermaid
graph TD
    A[Usu√°rio] --> T[Triagem]

    T -->|Cr√©dito| C[Cr√©dito]
    T -->|C√¢mbio| X[C√¢mbio]
    T -->|Atualiza√ß√£o| I[Entrevista]

    C -->|Rejeitado| I
    I -->|Dados Completos| C
    C -->|Aprovado| F[Fim]
    X --> F
```
> **Nota sobre o Roteamento:** O roteamento ocorre atrav√©s da vari√°vel `next_agent`, interpretada por um n√≥ de decis√£o configurado no orquestrador.

## üîç Estrat√©gias T√©cnicas Implementadas

### 1. Separa√ß√£o total entre l√≥gica de neg√≥cios e LLM
Nenhum c√°lculo financeiro depende do modelo de linguagem. Todos os valores s√£o processados por fun√ß√µes Python puras para garantir precis√£o:
* `validar_cliente`
* `processar_solicitacao_aumento`
* `calcular_atualizar_score`
* `consultar_cotacao_real`

### 2. Preven√ß√£o de loops e alucina√ß√µes
Para garantir a estabilidade do sistema, foram adotadas as seguintes configura√ß√µes:
* **Par√¢metros do Modelo:** `temperature=0`, `max_retries=0`.
* **Estrutura:** Prompts orientados a regras e orquestra√ß√£o determin√≠stica via grafo.

### 3. Persist√™ncia de Sess√£o
O uso de `thread_id` permite a reconstru√ß√£o de estado mesmo quando somente a √∫ltima mensagem √© enviada da Interface de Usu√°rio (UI) para o grafo.

### 4. UI desacoplada do estado interno
A interface em **Streamlit** exibe o hist√≥rico ao usu√°rio, mas somente a √∫ltima mensagem √© enviada ao grafo, garantindo:
* N√£o repeti√ß√£o de etapas.
* Correto disparo de transi√ß√µes.
* Execu√ß√£o isolada por agente.

---

## üìä Regras de Neg√≥cio Implementadas

### An√°lise de Cr√©dito
* Valida√ß√£o de limite m√°ximo por score (via CSV).
* C√°lculo determin√≠stico no Python.
* Registro de auditoria.
* Proposta autom√°tica de entrevista quando necess√°rio.

### Rec√°lculo de Score
* Coleta condicional de **5 vari√°veis**.
* O LLM dispara a *tool* somente ap√≥s todos os dados serem preenchidos.
* Atualiza√ß√£o de score persistida no estado.

### C√¢mbio
* *Tool* mandat√≥ria para respostas com n√∫meros.
* Garante precis√£o absoluta dos valores retornados.

---

## üß™ Cen√°rios de Teste Validados

* **1. Autentica√ß√£o + inten√ß√£o correta:** Triagem identifica cr√©dito/c√¢mbio/atualiza√ß√£o mesmo em frases amb√≠guas.
* **2. Recusa ‚Üí entrevista ‚Üí aceita√ß√£o:** Fluxo completo validado com score baixo e posterior reavalia√ß√£o.
* **3. Comandos diretos:** Ex.: *"Quero 2000"* √© interpretado corretamente como solicita√ß√£o de aumento.
* **4. Preven√ß√£o de loops:** Cada agente roda isoladamente, sem se repetir ou retornar para triagem indevidamente.

---

## üì¶ Estrutura do Projeto

```plaintext
src/
  ‚îú‚îÄ‚îÄ agents/
  ‚îÇ    ‚îú‚îÄ‚îÄ triage_agent.py
  ‚îÇ    ‚îú‚îÄ‚îÄ credit_agent.py
  ‚îÇ    ‚îú‚îÄ‚îÄ interview_agent.py
  ‚îÇ    ‚îî‚îÄ‚îÄ exchange_agent.py
  ‚îú‚îÄ‚îÄ core/
  ‚îÇ    ‚îú‚îÄ‚îÄ orchestrator.py
  ‚îÇ    ‚îî‚îÄ‚îÄ state.py
  ‚îú‚îÄ‚îÄ tools/
  ‚îÇ    ‚îú‚îÄ‚îÄ file_ops.py
  ‚îÇ    ‚îú‚îÄ‚îÄ credit_ops.py
  ‚îÇ    ‚îú‚îÄ‚îÄ score_calculator.py
  ‚îÇ    ‚îî‚îÄ‚îÄ currency_ops.py
  ‚îî‚îÄ‚îÄ ui/
  |      ‚îî‚îÄ‚îÄ streamlit_app.py
  |
  ‚îî‚îÄ‚îÄdata/
        ‚îú‚îÄ‚îÄ clientes.csv
        ‚îú‚îÄ‚îÄ score_limit.csv
        ‚îî‚îÄ‚îÄ ...
```

---

## üöÄ Execu√ß√£o Local (Quickstart)

### 1. Instala√ß√£o
Execute o comando abaixo para instalar as depend√™ncias (foi utilizado o pip freeze > requirements.txt para que as vers√µes das dependencias em qualquer m√°quina fossem coerentes com a m√°quina local):

```bash
pip install -r requirements.txt
```

### 2. Configura√ß√£o de ambiente
Crie um arquivo `.env` na raiz do projeto com o seguinte conte√∫do:

```ini
GOOGLE_API_KEY="sua-chave"
```

### 3. Execu√ß√£o
Inicie a aplica√ß√£o Streamlit:

```bash
python -m streamlit run src/ui/streamlit_app.py
```

---

## üõ°Ô∏è Considera√ß√µes de Seguran√ßa

* Arquivo `.env` ignorado via `.gitignore`.
* Nenhum segredo exposto em c√≥digo-fonte.
* Todas as decis√µes financeiras s√£o executadas em Python (n√£o no LLM).
* Log de auditoria implementado para solicita√ß√µes de cr√©dito.

---

## üìà Poss√≠veis Evolu√ß√µes (Produ√ß√£o)

* Persist√™ncia distribu√≠da via **Redis**.
* Observabilidade via **LangSmith** ou **Datadog**.
* Gest√£o de segredos via **Google Secrets Manager** (chaves do projeto, retirar o .env, fazer gerenciamento em cloud e gest√£o de seguran√ßa).
* **RAG** (Retrieval-Augmented Generation) para pol√≠ticas internas do banco, informa√ß√µes da moeda ou aprimoramento sobre investimentos (B3 por exemplo).
* Uso de pipeline integrada via Terraform/Tekton e Google Cloud para gerenciamento de seguran√ßa e confiabilidade.
* Infraestrura com google cloud: backend para midware (Flask) + Agentic-RAG + arquiteturamulti-agente com lang-graph + chatbot Frontend.

---
Essa aplica√ß√£o foi desenvolvida por Priscila C. Ara√∫jo