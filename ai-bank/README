# ğŸ¦ Banco Ãgil â€” Sistema de Atendimento Inteligente com Arquitetura Multi-Agente

## ğŸ“Œ SumÃ¡rio Executivo

Este projeto implementa um sistema de atendimento bancÃ¡rio utilizando uma **arquitetura de agentes especializados**, orquestrados por um **StateGraph do LangGraph**, garantindo controle determinÃ­stico de fluxo, persistÃªncia contextual e execuÃ§Ã£o orientada a regras de negÃ³cio.

O objetivo Ã© simular um ambiente de atendimento realista, porÃ©m com seguranÃ§a, previsibilidade e auditabilidade â€” caracterÃ­sticas essenciais em cenÃ¡rios financeiros.

---

## ğŸ§© Arquitetura Geral

A soluÃ§Ã£o Ã© composta por quatro agentes independentes:

- **Triagem:** AutenticaÃ§Ã£o + intenÃ§Ã£o.
- **CrÃ©dito:** AnÃ¡lise de aumento de limite com regras determinÃ­sticas.
- **Entrevista:** Coleta estruturada de dados para recÃ¡lculo de score.
- **CÃ¢mbio:** Consulta de cotaÃ§Ãµes via tool.

A interaÃ§Ã£o entre os agentes Ã© controlada pelo **LangGraph (StateGraph)**, que permite:

- Roteamento baseado em estado.
- Ciclos (ex.: rejeiÃ§Ã£o â†’ entrevista â†’ crÃ©dito).
- PersistÃªncia de estado por sessÃ£o/thread.
- Controle explÃ­cito de transiÃ§Ãµes via ferramentas e lÃ³gica Python.

---

## ğŸ”§ Tecnologias Utilizadas

| Componente | Tecnologia | Justificativa |
| :--- | :--- | :--- |
| **OrquestraÃ§Ã£o** | **LangGraph** | Permite modelos com loops, roteamento condicional e estado persistente. |
| **LLM** | **Google Gemini 1.5 Flash** | Baixo custo, rÃ¡pidas tool-calls, ideal para classificaÃ§Ã£o e roteamento. |
| **Interface** | **Streamlit** | Facilita implementaÃ§Ã£o de chat interativo para validaÃ§Ã£o visual. |
| **Tools** | **FunÃ§Ãµes Python** | Evita alucinaÃ§Ãµes e garante deterministicidade em cÃ¡lculos financeiros. |

---

## ğŸ›ï¸ Modelo de Estado (AgentState)

O sistema utiliza um dicionÃ¡rio tipado responsÃ¡vel por consolidar:

- HistÃ³rico de mensagens.
- Dados do cliente (CPF, nome, score, limite).
- Flags essenciais (`authenticated`, `interview_complete`, `next_agent`, `last_intent`).

O uso de `Annotated` permite operaÃ§Ãµes de merge customizadas para histÃ³rico e variÃ¡veis persistentes.

---

## ğŸ”€ Fluxo entre Agentes (StateGraph)

A arquitetura segue o seguinte fluxo:

```mermaid
graph TD
    A[UsuÃ¡rio] --> T[Triagem]

    T -->|CrÃ©dito| C[CrÃ©dito]
    T -->|CÃ¢mbio| X[CÃ¢mbio]
    T -->|AtualizaÃ§Ã£o| I[Entrevista]

    C -->|Rejeitado| I
    I -->|Dados Completos| C
    C -->|Aprovado| F[Fim]
    X --> F
```
> **Nota sobre o Roteamento:** O roteamento ocorre atravÃ©s da variÃ¡vel `next_agent`, interpretada por um nÃ³ de decisÃ£o configurado no orquestrador.

## ğŸ” EstratÃ©gias TÃ©cnicas Implementadas

### 1. SeparaÃ§Ã£o total entre lÃ³gica de negÃ³cios e LLM
Nenhum cÃ¡lculo financeiro depende do modelo de linguagem. Todos os valores sÃ£o processados por funÃ§Ãµes Python puras para garantir precisÃ£o:
* `validar_cliente`
* `processar_solicitacao_aumento`
* `calcular_atualizar_score`
* `consultar_cotacao_real`

### 2. PrevenÃ§Ã£o de loops e alucinaÃ§Ãµes
Para garantir a estabilidade do sistema, foram adotadas as seguintes configuraÃ§Ãµes:
* **ParÃ¢metros do Modelo:** `temperature=0`, `max_retries=0`.
* **Estrutura:** Prompts orientados a regras e orquestraÃ§Ã£o determinÃ­stica via grafo.

### 3. PersistÃªncia de SessÃ£o
O uso de `thread_id` permite a reconstruÃ§Ã£o de estado mesmo quando somente a Ãºltima mensagem Ã© enviada da Interface de UsuÃ¡rio (UI) para o grafo.

### 4. UI desacoplada do estado interno
A interface em **Streamlit** exibe o histÃ³rico ao usuÃ¡rio, mas somente a Ãºltima mensagem Ã© enviada ao grafo, garantindo:
* NÃ£o repetiÃ§Ã£o de etapas.
* Correto disparo de transiÃ§Ãµes.
* ExecuÃ§Ã£o isolada por agente.

---

## ğŸ“Š Regras de NegÃ³cio Implementadas

### AnÃ¡lise de CrÃ©dito
* ValidaÃ§Ã£o de limite mÃ¡ximo por score (via CSV).
* CÃ¡lculo determinÃ­stico no Python.
* Registro de auditoria.
* Proposta automÃ¡tica de entrevista quando necessÃ¡rio.

### RecÃ¡lculo de Score
* Coleta condicional de **5 variÃ¡veis**.
* O LLM dispara a *tool* somente apÃ³s todos os dados serem preenchidos.
* AtualizaÃ§Ã£o de score persistida no estado.

### CÃ¢mbio
* *Tool* mandatÃ³ria para respostas com nÃºmeros.
* Garante precisÃ£o absoluta dos valores retornados.

---

## ğŸ§ª CenÃ¡rios de Teste Validados

* **1. AutenticaÃ§Ã£o + intenÃ§Ã£o correta:** Triagem identifica crÃ©dito/cÃ¢mbio/atualizaÃ§Ã£o mesmo em frases ambÃ­guas.
* **2. Recusa â†’ entrevista â†’ aceitaÃ§Ã£o:** Fluxo completo validado com score baixo e posterior reavaliaÃ§Ã£o.
* **3. Comandos diretos:** Ex.: *"Quero 2000"* Ã© interpretado corretamente como solicitaÃ§Ã£o de aumento.
* **4. PrevenÃ§Ã£o de loops:** Cada agente roda isoladamente, sem se repetir ou retornar para triagem indevidamente.

---

## ğŸ“¦ Estrutura do Projeto

```plaintext
src/
  â”œâ”€â”€ agents/
  â”‚    â”œâ”€â”€ triage_agent.py
  â”‚    â”œâ”€â”€ credit_agent.py
  â”‚    â”œâ”€â”€ interview_agent.py
  â”‚    â””â”€â”€ exchange_agent.py
  â”œâ”€â”€ core/
  â”‚    â”œâ”€â”€ orchestrator.py
  â”‚    â””â”€â”€ state.py
  â”œâ”€â”€ tools/
  â”‚    â”œâ”€â”€ file_ops.py
  â”‚    â”œâ”€â”€ credit_ops.py
  â”‚    â”œâ”€â”€ score_calculator.py
  â”‚    â””â”€â”€ currency_ops.py
  â””â”€â”€ ui/
       â””â”€â”€ streamlit_app.py
data/
  â”œâ”€â”€ clientes.csv
  â”œâ”€â”€ limites_credito.csv
  â””â”€â”€ ...
```

---

## ğŸš€ ExecuÃ§Ã£o Local (Quickstart)

### 1. InstalaÃ§Ã£o
Execute o comando abaixo para instalar as dependÃªncias:

```bash
pip install -r requirements.txt
```

### 2. ConfiguraÃ§Ã£o de ambiente
Crie um arquivo `.env` na raiz do projeto com o seguinte conteÃºdo:

```ini
GOOGLE_API_KEY="sua-chave"
```

### 3. ExecuÃ§Ã£o
Inicie a aplicaÃ§Ã£o Streamlit:

```bash
python -m streamlit run src/ui/streamlit_app.py
```

---

## ğŸ›¡ï¸ ConsideraÃ§Ãµes de SeguranÃ§a

* Arquivo `.env` ignorado via `.gitignore`.
* Nenhum segredo exposto em cÃ³digo-fonte.
* Todas as decisÃµes financeiras sÃ£o executadas em Python (nÃ£o no LLM).
* Log de auditoria implementado para solicitaÃ§Ãµes de crÃ©dito.

---

## ğŸ“ˆ PossÃ­veis EvoluÃ§Ãµes (ProduÃ§Ã£o)

* PersistÃªncia distribuÃ­da via **Redis**.
* Observabilidade via **LangSmith** ou **Datadog**.
* GestÃ£o de segredos via **AWS Secrets Manager**.
* **RAG** (Retrieval-Augmented Generation) para polÃ­ticas internas do banco.
* Versionamento de estados do grafo para auditoria regulatÃ³ria.